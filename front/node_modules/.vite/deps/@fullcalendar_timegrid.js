import {
  DayTable
} from "./chunk-EOOX4ABT.js";
import {
  BaseComponent,
  BgEvent,
  DateComponent,
  DayCellContent,
  DayCellRoot,
  DayHeader,
  DaySeriesModel,
  DayTableModel,
  Fragment,
  MoreLinkRoot,
  NowIndicatorRoot,
  NowTimer,
  PositionCache,
  RefMap,
  RenderHook,
  SegHierarchy,
  SimpleScrollGrid,
  Slicer,
  Splitter,
  StandardEvent,
  ViewContextType,
  ViewRoot,
  WeekNumberRoot,
  addDurations,
  asRoughMs,
  binarySearch,
  buildEntryKey,
  buildEventRangeKey,
  buildIsoString,
  buildNavLinkAttrs,
  computeEarliestSegStart,
  createDuration,
  createElement,
  createFormatter,
  createPlugin,
  createRef,
  diffDays,
  formatIsoTimeString,
  getEntrySpanEnd,
  getSegMeta,
  getStickyFooterScrollbar,
  getStickyHeaderDates,
  groupIntersectingEntries,
  hasBgRendering,
  intersectRanges,
  memoize,
  multiplyDuration,
  rangeContainsMarker,
  renderFill,
  renderScrollShim,
  setRef,
  sortEventSegs,
  startOfDay,
  wholeDivideDurations
} from "./chunk-SI5S43G7.js";
import {
  __assign,
  __extends
} from "./chunk-EXAMLBMZ.js";
import "./chunk-TFWDKVI3.js";

// node_modules/@fullcalendar/timegrid/main.js
import "/home/seb/Desktop/gt/front/node_modules/@fullcalendar/timegrid/main.css";
var AllDaySplitter = (
  /** @class */
  function(_super) {
    __extends(AllDaySplitter2, _super);
    function AllDaySplitter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AllDaySplitter2.prototype.getKeyInfo = function() {
      return {
        allDay: {},
        timed: {}
      };
    };
    AllDaySplitter2.prototype.getKeysForDateSpan = function(dateSpan) {
      if (dateSpan.allDay) {
        return ["allDay"];
      }
      return ["timed"];
    };
    AllDaySplitter2.prototype.getKeysForEventDef = function(eventDef) {
      if (!eventDef.allDay) {
        return ["timed"];
      }
      if (hasBgRendering(eventDef)) {
        return ["timed", "allDay"];
      }
      return ["allDay"];
    };
    return AllDaySplitter2;
  }(Splitter)
);
var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "short"
});
function TimeColsAxisCell(props) {
  var classNames = [
    "fc-timegrid-slot",
    "fc-timegrid-slot-label",
    props.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"
  ];
  return createElement(ViewContextType.Consumer, null, function(context) {
    if (!props.isLabeled) {
      return createElement("td", { className: classNames.join(" "), "data-time": props.isoTimeStr });
    }
    var dateEnv = context.dateEnv, options = context.options, viewApi = context.viewApi;
    var labelFormat = (
      // TODO: fully pre-parse
      options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat)
    );
    var hookProps = {
      level: 0,
      time: props.time,
      date: dateEnv.toDate(props.date),
      view: viewApi,
      text: dateEnv.format(props.date, labelFormat)
    };
    return createElement(RenderHook, { hookProps, classNames: options.slotLabelClassNames, content: options.slotLabelContent, defaultContent: renderInnerContent, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, function(rootElRef, customClassNames, innerElRef, innerContent) {
      return createElement(
        "td",
        { ref: rootElRef, className: classNames.concat(customClassNames).join(" "), "data-time": props.isoTimeStr },
        createElement(
          "div",
          { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
          createElement("div", { className: "fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion", ref: innerElRef }, innerContent)
        )
      );
    });
  });
}
function renderInnerContent(props) {
  return props.text;
}
var TimeBodyAxis = (
  /** @class */
  function(_super) {
    __extends(TimeBodyAxis2, _super);
    function TimeBodyAxis2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeBodyAxis2.prototype.render = function() {
      return this.props.slatMetas.map(function(slatMeta) {
        return createElement(
          "tr",
          { key: slatMeta.key },
          createElement(TimeColsAxisCell, __assign({}, slatMeta))
        );
      });
    };
    return TimeBodyAxis2;
  }(BaseComponent)
);
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "short" });
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
var TimeColsView = (
  /** @class */
  function(_super) {
    __extends(TimeColsView2, _super);
    function TimeColsView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.allDaySplitter = new AllDaySplitter();
      _this.headerElRef = createRef();
      _this.rootElRef = createRef();
      _this.scrollerElRef = createRef();
      _this.state = {
        slatCoords: null
      };
      _this.handleScrollTopRequest = function(scrollTop) {
        var scrollerEl = _this.scrollerElRef.current;
        if (scrollerEl) {
          scrollerEl.scrollTop = scrollTop;
        }
      };
      _this.renderHeadAxis = function(rowKey, frameHeight) {
        if (frameHeight === void 0) {
          frameHeight = "";
        }
        var options = _this.context.options;
        var dateProfile = _this.props.dateProfile;
        var range = dateProfile.renderRange;
        var dayCnt = diffDays(range.start, range.end);
        var navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(_this.context, range.start, "week") : {};
        if (options.weekNumbers && rowKey === "day") {
          return createElement(WeekNumberRoot, { date: range.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, function(rootElRef, classNames, innerElRef, innerContent) {
            return createElement(
              "th",
              { ref: rootElRef, "aria-hidden": true, className: [
                "fc-timegrid-axis",
                "fc-scrollgrid-shrink"
              ].concat(classNames).join(" ") },
              createElement(
                "div",
                { className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid", style: { height: frameHeight } },
                createElement("a", __assign({ ref: innerElRef, className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner" }, navLinkAttrs), innerContent)
              )
            );
          });
        }
        return createElement(
          "th",
          { "aria-hidden": true, className: "fc-timegrid-axis" },
          createElement("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })
        );
      };
      _this.renderTableRowAxis = function(rowHeight) {
        var _a = _this.context, options = _a.options, viewApi = _a.viewApi;
        var hookProps = {
          text: options.allDayText,
          view: viewApi
        };
        return (
          // TODO: make reusable hook. used in list view too
          createElement(RenderHook, { hookProps, classNames: options.allDayClassNames, content: options.allDayContent, defaultContent: renderAllDayInner, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, function(rootElRef, classNames, innerElRef, innerContent) {
            return createElement(
              "td",
              { ref: rootElRef, "aria-hidden": true, className: [
                "fc-timegrid-axis",
                "fc-scrollgrid-shrink"
              ].concat(classNames).join(" ") },
              createElement(
                "div",
                { className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame" + (rowHeight == null ? " fc-timegrid-axis-frame-liquid" : ""), style: { height: rowHeight } },
                createElement("span", { className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner", ref: innerElRef }, innerContent)
              )
            );
          })
        );
      };
      _this.handleSlatCoords = function(slatCoords) {
        _this.setState({ slatCoords });
      };
      return _this;
    }
    TimeColsView2.prototype.renderSimpleLayout = function(headerRowContent, allDayContent, timeContent) {
      var _a = this, context = _a.context, props = _a.props;
      var sections = [];
      var stickyHeaderDates = getStickyHeaderDates(context.options);
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          chunk: {
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        });
      }
      if (allDayContent) {
        sections.push({
          type: "body",
          key: "all-day",
          chunk: { content: allDayContent }
        });
        sections.push({
          type: "body",
          key: "all-day-divider",
          outerContent: (
            // TODO: rename to cellContent so don't need to define <tr>?
            createElement(
              "tr",
              { role: "presentation", className: "fc-scrollgrid-section" },
              createElement("td", { className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
            )
          )
        });
      }
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        expandRows: Boolean(context.options.expandRows),
        chunk: {
          scrollerElRef: this.scrollerElRef,
          content: timeContent
        }
      });
      return createElement(ViewRoot, { viewSpec: context.viewSpec, elRef: this.rootElRef }, function(rootElRef, classNames) {
        return createElement(
          "div",
          { className: ["fc-timegrid"].concat(classNames).join(" "), ref: rootElRef },
          createElement(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: "shrink" }], sections })
        );
      });
    };
    TimeColsView2.prototype.renderHScrollLayout = function(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
      var _this = this;
      var ScrollGrid = this.context.pluginHooks.scrollGridImpl;
      if (!ScrollGrid) {
        throw new Error("No ScrollGrid implementation");
      }
      var _a = this, context = _a.context, props = _a.props;
      var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
      var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
      var sections = [];
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          syncRowHeights: true,
          chunks: [
            {
              key: "axis",
              rowContent: function(arg) {
                return createElement("tr", { role: "presentation" }, _this.renderHeadAxis("day", arg.rowSyncHeights[0]));
              }
            },
            {
              key: "cols",
              elRef: this.headerElRef,
              tableClassName: "fc-col-header",
              rowContent: headerRowContent
            }
          ]
        });
      }
      if (allDayContent) {
        sections.push({
          type: "body",
          key: "all-day",
          syncRowHeights: true,
          chunks: [
            {
              key: "axis",
              rowContent: function(contentArg) {
                return createElement("tr", { role: "presentation" }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));
              }
            },
            {
              key: "cols",
              content: allDayContent
            }
          ]
        });
        sections.push({
          key: "all-day-divider",
          type: "body",
          outerContent: (
            // TODO: rename to cellContent so don't need to define <tr>?
            createElement(
              "tr",
              { role: "presentation", className: "fc-scrollgrid-section" },
              createElement("td", { colSpan: 2, className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
            )
          )
        });
      }
      var isNowIndicator = context.options.nowIndicator;
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        expandRows: Boolean(context.options.expandRows),
        chunks: [
          {
            key: "axis",
            content: function(arg) {
              return (
                // TODO: make this now-indicator arrow more DRY with TimeColsContent
                createElement(
                  "div",
                  { className: "fc-timegrid-axis-chunk" },
                  createElement(
                    "table",
                    { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : "" } },
                    arg.tableColGroupNode,
                    createElement(
                      "tbody",
                      null,
                      createElement(TimeBodyAxis, { slatMetas })
                    )
                  ),
                  createElement(
                    "div",
                    { className: "fc-timegrid-now-indicator-container" },
                    createElement(NowTimer, {
                      unit: isNowIndicator ? "minute" : "day"
                      /* hacky */
                    }, function(nowDate) {
                      var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate);
                      if (typeof nowIndicatorTop === "number") {
                        return createElement(NowIndicatorRoot, { isAxis: true, date: nowDate }, function(rootElRef, classNames, innerElRef, innerContent) {
                          return createElement("div", { ref: rootElRef, className: ["fc-timegrid-now-indicator-arrow"].concat(classNames).join(" "), style: { top: nowIndicatorTop } }, innerContent);
                        });
                      }
                      return null;
                    })
                  )
                )
              );
            }
          },
          {
            key: "cols",
            scrollerElRef: this.scrollerElRef,
            content: timeContent
          }
        ]
      });
      if (stickyFooterScrollbar) {
        sections.push({
          key: "footer",
          type: "footer",
          isSticky: true,
          chunks: [
            {
              key: "axis",
              content: renderScrollShim
            },
            {
              key: "cols",
              content: renderScrollShim
            }
          ]
        });
      }
      return createElement(ViewRoot, { viewSpec: context.viewSpec, elRef: this.rootElRef }, function(rootElRef, classNames) {
        return createElement(
          "div",
          { className: ["fc-timegrid"].concat(classNames).join(" "), ref: rootElRef },
          createElement(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: false, colGroups: [
            { width: "shrink", cols: [{ width: "shrink" }] },
            { cols: [{ span: colCnt, minWidth: dayMinWidth }] }
          ], sections })
        );
      });
    };
    TimeColsView2.prototype.getAllDayMaxEventProps = function() {
      var _a = this.context.options, dayMaxEvents = _a.dayMaxEvents, dayMaxEventRows = _a.dayMaxEventRows;
      if (dayMaxEvents === true || dayMaxEventRows === true) {
        dayMaxEvents = void 0;
        dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS;
      }
      return { dayMaxEvents, dayMaxEventRows };
    };
    return TimeColsView2;
  }(DateComponent)
);
function renderAllDayInner(hookProps) {
  return hookProps.text;
}
var TimeColsSlatsCoords = (
  /** @class */
  function() {
    function TimeColsSlatsCoords2(positions, dateProfile, slotDuration) {
      this.positions = positions;
      this.dateProfile = dateProfile;
      this.slotDuration = slotDuration;
    }
    TimeColsSlatsCoords2.prototype.safeComputeTop = function(date) {
      var dateProfile = this.dateProfile;
      if (rangeContainsMarker(dateProfile.currentRange, date)) {
        var startOfDayDate = startOfDay(date);
        var timeMs = date.valueOf() - startOfDayDate.valueOf();
        if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
          return this.computeTimeTop(createDuration(timeMs));
        }
      }
      return null;
    };
    TimeColsSlatsCoords2.prototype.computeDateTop = function(when, startOfDayDate) {
      if (!startOfDayDate) {
        startOfDayDate = startOfDay(when);
      }
      return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
    };
    TimeColsSlatsCoords2.prototype.computeTimeTop = function(duration) {
      var _a = this, positions = _a.positions, dateProfile = _a.dateProfile;
      var len = positions.els.length;
      var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
      var slatIndex;
      var slatRemainder;
      slatCoverage = Math.max(0, slatCoverage);
      slatCoverage = Math.min(len, slatCoverage);
      slatIndex = Math.floor(slatCoverage);
      slatIndex = Math.min(slatIndex, len - 1);
      slatRemainder = slatCoverage - slatIndex;
      return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
    };
    return TimeColsSlatsCoords2;
  }()
);
var TimeColsSlatsBody = (
  /** @class */
  function(_super) {
    __extends(TimeColsSlatsBody2, _super);
    function TimeColsSlatsBody2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeColsSlatsBody2.prototype.render = function() {
      var _a = this, props = _a.props, context = _a.context;
      var options = context.options;
      var slatElRefs = props.slatElRefs;
      return createElement("tbody", null, props.slatMetas.map(function(slatMeta, i) {
        var hookProps = {
          time: slatMeta.time,
          date: context.dateEnv.toDate(slatMeta.date),
          view: context.viewApi
        };
        var classNames = [
          "fc-timegrid-slot",
          "fc-timegrid-slot-lane",
          slatMeta.isLabeled ? "" : "fc-timegrid-slot-minor"
        ];
        return createElement(
          "tr",
          { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
          props.axis && createElement(TimeColsAxisCell, __assign({}, slatMeta)),
          createElement(RenderHook, { hookProps, classNames: options.slotLaneClassNames, content: options.slotLaneContent, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, function(rootElRef, customClassNames, innerElRef, innerContent) {
            return createElement("td", { ref: rootElRef, className: classNames.concat(customClassNames).join(" "), "data-time": slatMeta.isoTimeStr }, innerContent);
          })
        );
      }));
    };
    return TimeColsSlatsBody2;
  }(BaseComponent)
);
var TimeColsSlats = (
  /** @class */
  function(_super) {
    __extends(TimeColsSlats2, _super);
    function TimeColsSlats2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootElRef = createRef();
      _this.slatElRefs = new RefMap();
      return _this;
    }
    TimeColsSlats2.prototype.render = function() {
      var _a = this, props = _a.props, context = _a.context;
      return createElement(
        "div",
        { ref: this.rootElRef, className: "fc-timegrid-slots" },
        createElement(
          "table",
          { "aria-hidden": true, className: context.theme.getClass("table"), style: {
            minWidth: props.tableMinWidth,
            width: props.clientWidth,
            height: props.minHeight
          } },
          props.tableColGroupNode,
          createElement(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas })
        )
      );
    };
    TimeColsSlats2.prototype.componentDidMount = function() {
      this.updateSizing();
    };
    TimeColsSlats2.prototype.componentDidUpdate = function() {
      this.updateSizing();
    };
    TimeColsSlats2.prototype.componentWillUnmount = function() {
      if (this.props.onCoords) {
        this.props.onCoords(null);
      }
    };
    TimeColsSlats2.prototype.updateSizing = function() {
      var _a = this, context = _a.context, props = _a.props;
      if (props.onCoords && props.clientWidth !== null) {
        var rootEl = this.rootElRef.current;
        if (rootEl.offsetHeight) {
          props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
        }
      }
    };
    return TimeColsSlats2;
  }(BaseComponent)
);
function collectSlatEls(elMap, slatMetas) {
  return slatMetas.map(function(slatMeta) {
    return elMap[slatMeta.key];
  });
}
function splitSegsByCol(segs, colCnt) {
  var segsByCol = [];
  var i;
  for (i = 0; i < colCnt; i += 1) {
    segsByCol.push([]);
  }
  if (segs) {
    for (i = 0; i < segs.length; i += 1) {
      segsByCol[segs[i].col].push(segs[i]);
    }
  }
  return segsByCol;
}
function splitInteractionByCol(ui, colCnt) {
  var byRow = [];
  if (!ui) {
    for (var i = 0; i < colCnt; i += 1) {
      byRow[i] = null;
    }
  } else {
    for (var i = 0; i < colCnt; i += 1) {
      byRow[i] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {
      var seg = _a[_i];
      byRow[seg.col].segs.push(seg);
    }
  }
  return byRow;
}
var TimeColMoreLink = (
  /** @class */
  function(_super) {
    __extends(TimeColMoreLink2, _super);
    function TimeColMoreLink2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootElRef = createRef();
      return _this;
    }
    TimeColMoreLink2.prototype.render = function() {
      var _this = this;
      var props = this.props;
      return createElement(MoreLinkRoot, { allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, alignmentElRef: this.rootElRef, defaultContent: renderMoreLinkInner, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: function() {
        return renderPlainFgSegs(props.hiddenSegs, props);
      } }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
        return createElement(
          "a",
          { ref: function(el) {
            setRef(rootElRef, el);
            setRef(_this.rootElRef, el);
          }, className: ["fc-timegrid-more-link"].concat(classNames).join(" "), style: { top: props.top, bottom: props.bottom }, onClick: handleClick, title, "aria-expanded": isExpanded, "aria-controls": popoverId },
          createElement("div", { ref: innerElRef, className: "fc-timegrid-more-link-inner fc-sticky" }, innerContent)
        );
      });
    };
    return TimeColMoreLink2;
  }(BaseComponent)
);
function renderMoreLinkInner(props) {
  return props.shortText;
}
function buildPositioning(segInputs, strictOrder, maxStackCnt) {
  var hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  var hiddenEntries = hierarchy.addSegs(segInputs);
  var hiddenGroups = groupIntersectingEntries(hiddenEntries);
  var web = buildWeb(hierarchy);
  web = stretchWeb(web, 1);
  var segRects = webToRects(web);
  return { segRects, hiddenGroups };
}
function buildWeb(hierarchy) {
  var entriesByLevel = hierarchy.entriesByLevel;
  var buildNode = cacheable(function(level, lateral) {
    return level + ":" + lateral;
  }, function(level, lateral) {
    var siblingRange = findNextLevelSegs(hierarchy, level, lateral);
    var nextLevelRes = buildNodes(siblingRange, buildNode);
    var entry = entriesByLevel[level][lateral];
    return [
      __assign(__assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
      entry.thickness + nextLevelRes[1]
      // the pressure builds
    ];
  });
  return buildNodes(entriesByLevel.length ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length } : null, buildNode)[0];
}
function buildNodes(siblingRange, buildNode) {
  if (!siblingRange) {
    return [[], 0];
  }
  var level = siblingRange.level, lateralStart = siblingRange.lateralStart, lateralEnd = siblingRange.lateralEnd;
  var lateral = lateralStart;
  var pairs = [];
  while (lateral < lateralEnd) {
    pairs.push(buildNode(level, lateral));
    lateral += 1;
  }
  pairs.sort(cmpDescPressures);
  return [
    pairs.map(extractNode),
    pairs[0][1]
    // first item's pressure
  ];
}
function cmpDescPressures(a, b) {
  return b[1] - a[1];
}
function extractNode(a) {
  return a[0];
}
function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
  var levelCoords = hierarchy.levelCoords, entriesByLevel = hierarchy.entriesByLevel;
  var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
  var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
  var levelCnt = levelCoords.length;
  var level = subjectLevel;
  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
    ;
  for (; level < levelCnt; level += 1) {
    var entries = entriesByLevel[level];
    var entry = void 0;
    var searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
    var lateralStart = searchIndex[0] + searchIndex[1];
    var lateralEnd = lateralStart;
    while (
      // loop through entries that horizontally intersect
      (entry = entries[lateralEnd]) && // but not past the whole seg list
      entry.span.start < subjectEntry.span.end
    ) {
      lateralEnd += 1;
    }
    if (lateralStart < lateralEnd) {
      return { level, lateralStart, lateralEnd };
    }
  }
  return null;
}
function stretchWeb(topLevelNodes, totalThickness) {
  var stretchNode = cacheable(function(node, startCoord, prevThickness) {
    return buildEntryKey(node);
  }, function(node, startCoord, prevThickness) {
    var nextLevelNodes = node.nextLevelNodes, thickness = node.thickness;
    var allThickness = thickness + prevThickness;
    var thicknessFraction = thickness / allThickness;
    var endCoord;
    var newChildren = [];
    if (!nextLevelNodes.length) {
      endCoord = totalThickness;
    } else {
      for (var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++) {
        var childNode = nextLevelNodes_1[_i];
        if (endCoord === void 0) {
          var res = stretchNode(childNode, startCoord, allThickness);
          endCoord = res[0];
          newChildren.push(res[1]);
        } else {
          var res = stretchNode(childNode, endCoord, 0);
          newChildren.push(res[1]);
        }
      }
    }
    var newThickness = (endCoord - startCoord) * thicknessFraction;
    return [endCoord - newThickness, __assign(__assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
  });
  return topLevelNodes.map(function(node) {
    return stretchNode(node, 0, 0)[1];
  });
}
function webToRects(topLevelNodes) {
  var rects = [];
  var processNode = cacheable(function(node, levelCoord, stackDepth) {
    return buildEntryKey(node);
  }, function(node, levelCoord, stackDepth) {
    var rect = __assign(__assign({}, node), {
      levelCoord,
      stackDepth,
      stackForward: 0
    });
    rects.push(rect);
    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
  });
  function processNodes(nodes, levelCoord, stackDepth) {
    var stackForward = 0;
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
      var node = nodes_1[_i];
      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
    }
    return stackForward;
  }
  processNodes(topLevelNodes, 0, 0);
  return rects;
}
function cacheable(keyFunc, workFunc) {
  var cache = {};
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = keyFunc.apply(void 0, args);
    return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);
  };
}
function computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {
  if (slatCoords === void 0) {
    slatCoords = null;
  }
  if (eventMinHeight === void 0) {
    eventMinHeight = 0;
  }
  var vcoords = [];
  if (slatCoords) {
    for (var i = 0; i < segs.length; i += 1) {
      var seg = segs[i];
      var spanStart = slatCoords.computeDateTop(seg.start, colDate);
      var spanEnd = Math.max(
        spanStart + (eventMinHeight || 0),
        // :(
        slatCoords.computeDateTop(seg.end, colDate)
      );
      vcoords.push({
        start: Math.round(spanStart),
        end: Math.round(spanEnd)
        //
      });
    }
  }
  return vcoords;
}
function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
  var segInputs = [];
  var dumbSegs = [];
  for (var i = 0; i < segs.length; i += 1) {
    var vcoords = segVCoords[i];
    if (vcoords) {
      segInputs.push({
        index: i,
        thickness: 1,
        span: vcoords
      });
    } else {
      dumbSegs.push(segs[i]);
    }
  }
  var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack), segRects = _a.segRects, hiddenGroups = _a.hiddenGroups;
  var segPlacements = [];
  for (var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++) {
    var segRect = segRects_1[_i];
    segPlacements.push({
      seg: segs[segRect.index],
      rect: segRect
    });
  }
  for (var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++) {
    var dumbSeg = dumbSegs_1[_b];
    segPlacements.push({ seg: dumbSeg, rect: null });
  }
  return { segPlacements, hiddenGroups };
}
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: false
});
var TimeColEvent = (
  /** @class */
  function(_super) {
    __extends(TimeColEvent2, _super);
    function TimeColEvent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeColEvent2.prototype.render = function() {
      var classNames = [
        "fc-timegrid-event",
        "fc-v-event"
      ];
      if (this.props.isShort) {
        classNames.push("fc-timegrid-event-short");
      }
      return createElement(StandardEvent, __assign({}, this.props, { defaultTimeFormat: DEFAULT_TIME_FORMAT, extraClassNames: classNames }));
    };
    return TimeColEvent2;
  }(BaseComponent)
);
var TimeColMisc = (
  /** @class */
  function(_super) {
    __extends(TimeColMisc2, _super);
    function TimeColMisc2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeColMisc2.prototype.render = function() {
      var props = this.props;
      return createElement(DayCellContent, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraHookProps: props.extraHookProps }, function(innerElRef, innerContent) {
        return innerContent && createElement("div", { className: "fc-timegrid-col-misc", ref: innerElRef }, innerContent);
      });
    };
    return TimeColMisc2;
  }(BaseComponent)
);
var TimeCol = (
  /** @class */
  function(_super) {
    __extends(TimeCol2, _super);
    function TimeCol2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sortEventSegs = memoize(sortEventSegs);
      return _this;
    }
    TimeCol2.prototype.render = function() {
      var _this = this;
      var _a = this, props = _a.props, context = _a.context;
      var isSelectMirror = context.options.selectMirror;
      var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];
      var interactionAffectedInstances = (
        // TODO: messy way to compute this
        props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
      );
      var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);
      return createElement(DayCellRoot, { elRef: props.elRef, date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraHookProps: props.extraHookProps }, function(rootElRef, classNames, dataAttrs) {
        return createElement(
          "td",
          __assign({ ref: rootElRef, role: "gridcell", className: ["fc-timegrid-col"].concat(classNames, props.extraClassNames || []).join(" ") }, dataAttrs, props.extraDataAttrs),
          createElement(
            "div",
            { className: "fc-timegrid-col-frame" },
            createElement(
              "div",
              { className: "fc-timegrid-col-bg" },
              _this.renderFillSegs(props.businessHourSegs, "non-business"),
              _this.renderFillSegs(props.bgEventSegs, "bg-event"),
              _this.renderFillSegs(props.dateSelectionSegs, "highlight")
            ),
            createElement("div", { className: "fc-timegrid-col-events" }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
            createElement("div", { className: "fc-timegrid-col-events" }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))),
            createElement("div", { className: "fc-timegrid-now-indicator-container" }, _this.renderNowIndicator(props.nowIndicatorSegs)),
            createElement(TimeColMisc, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraHookProps: props.extraHookProps })
          )
        );
      });
    };
    TimeCol2.prototype.renderFgSegs = function(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {
      var props = this.props;
      if (props.forPrint) {
        return renderPlainFgSegs(sortedFgSegs, props);
      }
      return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);
    };
    TimeCol2.prototype.renderPositionedFgSegs = function(segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {
      var _this = this;
      var _a = this.context.options, eventMaxStack = _a.eventMaxStack, eventShortHeight = _a.eventShortHeight, eventOrderStrict = _a.eventOrderStrict, eventMinHeight = _a.eventMinHeight;
      var _b = this.props, date = _b.date, slatCoords = _b.slatCoords, eventSelection = _b.eventSelection, todayRange = _b.todayRange, nowDate = _b.nowDate;
      var isMirror = isDragging || isResizing || isDateSelecting;
      var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
      var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack), segPlacements = _c.segPlacements, hiddenGroups = _c.hiddenGroups;
      return createElement(
        Fragment,
        null,
        this.renderHiddenGroups(hiddenGroups, segs),
        segPlacements.map(function(segPlacement) {
          var seg = segPlacement.seg, rect = segPlacement.rect;
          var instanceId = seg.eventRange.instance.instanceId;
          var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
          var vStyle = computeSegVStyle(rect && rect.span);
          var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : { left: 0, right: 0 };
          var isInset = Boolean(rect) && rect.stackForward > 0;
          var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight;
          return createElement(
            "div",
            { className: "fc-timegrid-event-harness" + (isInset ? " fc-timegrid-event-harness-inset" : ""), key: instanceId, style: __assign(__assign({ visibility: isVisible ? "" : "hidden" }, vStyle), hStyle) },
            createElement(TimeColEvent, __assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, isShort }, getSegMeta(seg, todayRange, nowDate)))
          );
        })
      );
    };
    TimeCol2.prototype.renderHiddenGroups = function(hiddenGroups, segs) {
      var _a = this.props, extraDateSpan = _a.extraDateSpan, dateProfile = _a.dateProfile, todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;
      return createElement(Fragment, null, hiddenGroups.map(function(hiddenGroup) {
        var positionCss = computeSegVStyle(hiddenGroup.span);
        var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
        return createElement(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize });
      }));
    };
    TimeCol2.prototype.renderFillSegs = function(segs, fillType) {
      var _a = this, props = _a.props, context = _a.context;
      var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight);
      var children = segVCoords.map(function(vcoords, i) {
        var seg = segs[i];
        return createElement("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === "bg-event" ? createElement(BgEvent, __assign({ seg }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
      });
      return createElement(Fragment, null, children);
    };
    TimeCol2.prototype.renderNowIndicator = function(segs) {
      var _a = this.props, slatCoords = _a.slatCoords, date = _a.date;
      if (!slatCoords) {
        return null;
      }
      return segs.map(function(seg, i) {
        return createElement(NowIndicatorRoot, {
          isAxis: false,
          date,
          // key doesn't matter. will only ever be one
          key: i
        }, function(rootElRef, classNames, innerElRef, innerContent) {
          return createElement("div", { ref: rootElRef, className: ["fc-timegrid-now-indicator-line"].concat(classNames).join(" "), style: { top: slatCoords.computeDateTop(seg.start, date) } }, innerContent);
        });
      });
    };
    TimeCol2.prototype.computeSegHStyle = function(segHCoords) {
      var _a = this.context, isRtl = _a.isRtl, options = _a.options;
      var shouldOverlap = options.slotEventOverlap;
      var nearCoord = segHCoords.levelCoord;
      var farCoord = segHCoords.levelCoord + segHCoords.thickness;
      var left;
      var right;
      if (shouldOverlap) {
        farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
      }
      if (isRtl) {
        left = 1 - farCoord;
        right = nearCoord;
      } else {
        left = nearCoord;
        right = 1 - farCoord;
      }
      var props = {
        zIndex: segHCoords.stackDepth + 1,
        left: left * 100 + "%",
        right: right * 100 + "%"
      };
      if (shouldOverlap && !segHCoords.stackForward) {
        props[isRtl ? "marginLeft" : "marginRight"] = 10 * 2;
      }
      return props;
    };
    return TimeCol2;
  }(BaseComponent)
);
function renderPlainFgSegs(sortedFgSegs, _a) {
  var todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;
  var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
  return createElement(Fragment, null, sortedFgSegs.map(function(seg) {
    var instanceId = seg.eventRange.instance.instanceId;
    return createElement(
      "div",
      { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? "hidden" : "" } },
      createElement(TimeColEvent, __assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))
    );
  }));
}
function computeSegVStyle(segVCoords) {
  if (!segVCoords) {
    return { top: "", bottom: "" };
  }
  return {
    top: segVCoords.start,
    bottom: -segVCoords.end
  };
}
function compileSegsFromEntries(segEntries, allSegs) {
  return segEntries.map(function(segEntry) {
    return allSegs[segEntry.index];
  });
}
var TimeColsContent = (
  /** @class */
  function(_super) {
    __extends(TimeColsContent2, _super);
    function TimeColsContent2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.splitFgEventSegs = memoize(splitSegsByCol);
      _this.splitBgEventSegs = memoize(splitSegsByCol);
      _this.splitBusinessHourSegs = memoize(splitSegsByCol);
      _this.splitNowIndicatorSegs = memoize(splitSegsByCol);
      _this.splitDateSelectionSegs = memoize(splitSegsByCol);
      _this.splitEventDrag = memoize(splitInteractionByCol);
      _this.splitEventResize = memoize(splitInteractionByCol);
      _this.rootElRef = createRef();
      _this.cellElRefs = new RefMap();
      return _this;
    }
    TimeColsContent2.prototype.render = function() {
      var _this = this;
      var _a = this, props = _a.props, context = _a.context;
      var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate);
      var colCnt = props.cells.length;
      var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
      var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
      var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
      var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
      var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
      var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
      var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
      return createElement(
        "div",
        { className: "fc-timegrid-cols", ref: this.rootElRef },
        createElement(
          "table",
          { role: "presentation", style: {
            minWidth: props.tableMinWidth,
            width: props.clientWidth
          } },
          props.tableColGroupNode,
          createElement(
            "tbody",
            { role: "presentation" },
            createElement(
              "tr",
              { role: "row" },
              props.axis && createElement(
                "td",
                { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
                createElement(
                  "div",
                  { className: "fc-timegrid-col-frame" },
                  createElement("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === "number" && createElement(NowIndicatorRoot, { isAxis: true, date: props.nowDate }, function(rootElRef, classNames, innerElRef, innerContent) {
                    return createElement("div", { ref: rootElRef, className: ["fc-timegrid-now-indicator-arrow"].concat(classNames).join(" "), style: { top: nowIndicatorTop } }, innerContent);
                  }))
                )
              ),
              props.cells.map(function(cell, i) {
                return createElement(TimeCol, { key: cell.key, elRef: _this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraHookProps: cell.extraHookProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i], bgEventSegs: bgEventSegsByRow[i], businessHourSegs: businessHourSegsByRow[i], nowIndicatorSegs: nowIndicatorSegsByRow[i], dateSelectionSegs: dateSelectionSegsByRow[i], eventDrag: eventDragByRow[i], eventResize: eventResizeByRow[i], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint });
              })
            )
          )
        )
      );
    };
    TimeColsContent2.prototype.componentDidMount = function() {
      this.updateCoords();
    };
    TimeColsContent2.prototype.componentDidUpdate = function() {
      this.updateCoords();
    };
    TimeColsContent2.prototype.updateCoords = function() {
      var props = this.props;
      if (props.onColCoords && props.clientWidth !== null) {
        props.onColCoords(new PositionCache(
          this.rootElRef.current,
          collectCellEls(this.cellElRefs.currentMap, props.cells),
          true,
          // horizontal
          false
        ));
      }
    };
    return TimeColsContent2;
  }(BaseComponent)
);
function collectCellEls(elMap, cells) {
  return cells.map(function(cell) {
    return elMap[cell.key];
  });
}
var TimeCols = (
  /** @class */
  function(_super) {
    __extends(TimeCols2, _super);
    function TimeCols2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.processSlotOptions = memoize(processSlotOptions);
      _this.state = {
        slatCoords: null
      };
      _this.handleRootEl = function(el) {
        if (el) {
          _this.context.registerInteractiveComponent(_this, {
            el,
            isHitComboAllowed: _this.props.isHitComboAllowed
          });
        } else {
          _this.context.unregisterInteractiveComponent(_this);
        }
      };
      _this.handleScrollRequest = function(request) {
        var onScrollTopRequest = _this.props.onScrollTopRequest;
        var slatCoords = _this.state.slatCoords;
        if (onScrollTopRequest && slatCoords) {
          if (request.time) {
            var top_1 = slatCoords.computeTimeTop(request.time);
            top_1 = Math.ceil(top_1);
            if (top_1) {
              top_1 += 1;
            }
            onScrollTopRequest(top_1);
          }
          return true;
        }
        return false;
      };
      _this.handleColCoords = function(colCoords) {
        _this.colCoords = colCoords;
      };
      _this.handleSlatCoords = function(slatCoords) {
        _this.setState({ slatCoords });
        if (_this.props.onSlatCoords) {
          _this.props.onSlatCoords(slatCoords);
        }
      };
      return _this;
    }
    TimeCols2.prototype.render = function() {
      var _a = this, props = _a.props, state = _a.state;
      return createElement(
        "div",
        { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
          // these props are important to give this wrapper correct dimensions for interactions
          // TODO: if we set it here, can we avoid giving to inner tables?
          width: props.clientWidth,
          minWidth: props.tableMinWidth
        } },
        createElement(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null, onCoords: this.handleSlatCoords }),
        createElement(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })
      );
    };
    TimeCols2.prototype.componentDidMount = function() {
      this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
    };
    TimeCols2.prototype.componentDidUpdate = function(prevProps) {
      this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
    };
    TimeCols2.prototype.componentWillUnmount = function() {
      this.scrollResponder.detach();
    };
    TimeCols2.prototype.queryHit = function(positionLeft, positionTop) {
      var _a = this.context, dateEnv = _a.dateEnv, options = _a.options;
      var colCoords = this.colCoords;
      var dateProfile = this.props.dateProfile;
      var slatCoords = this.state.slatCoords;
      var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration), snapDuration = _b.snapDuration, snapsPerSlot = _b.snapsPerSlot;
      var colIndex = colCoords.leftToIndex(positionLeft);
      var slatIndex = slatCoords.positions.topToIndex(positionTop);
      if (colIndex != null && slatIndex != null) {
        var cell = this.props.cells[colIndex];
        var slatTop = slatCoords.positions.tops[slatIndex];
        var slatHeight = slatCoords.positions.getHeight(slatIndex);
        var partial = (positionTop - slatTop) / slatHeight;
        var localSnapIndex = Math.floor(partial * snapsPerSlot);
        var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
        var dayDate = this.props.cells[colIndex].date;
        var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
        var start = dateEnv.add(dayDate, time);
        var end = dateEnv.add(start, snapDuration);
        return {
          dateProfile,
          dateSpan: __assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),
          dayEl: colCoords.els[colIndex],
          rect: {
            left: colCoords.lefts[colIndex],
            right: colCoords.rights[colIndex],
            top: slatTop,
            bottom: slatTop + slatHeight
          },
          layer: 0
        };
      }
      return null;
    };
    return TimeCols2;
  }(DateComponent)
);
function processSlotOptions(slotDuration, snapDurationOverride) {
  var snapDuration = snapDurationOverride || slotDuration;
  var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
  if (snapsPerSlot === null) {
    snapDuration = slotDuration;
    snapsPerSlot = 1;
  }
  return { snapDuration, snapsPerSlot };
}
var DayTimeColsSlicer = (
  /** @class */
  function(_super) {
    __extends(DayTimeColsSlicer2, _super);
    function DayTimeColsSlicer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DayTimeColsSlicer2.prototype.sliceRange = function(range, dayRanges) {
      var segs = [];
      for (var col = 0; col < dayRanges.length; col += 1) {
        var segRange = intersectRanges(range, dayRanges[col]);
        if (segRange) {
          segs.push({
            start: segRange.start,
            end: segRange.end,
            isStart: segRange.start.valueOf() === range.start.valueOf(),
            isEnd: segRange.end.valueOf() === range.end.valueOf(),
            col
          });
        }
      }
      return segs;
    };
    return DayTimeColsSlicer2;
  }(Slicer)
);
var DayTimeCols = (
  /** @class */
  function(_super) {
    __extends(DayTimeCols2, _super);
    function DayTimeCols2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buildDayRanges = memoize(buildDayRanges);
      _this.slicer = new DayTimeColsSlicer();
      _this.timeColsRef = createRef();
      return _this;
    }
    DayTimeCols2.prototype.render = function() {
      var _this = this;
      var _a = this, props = _a.props, context = _a.context;
      var dateProfile = props.dateProfile, dayTableModel = props.dayTableModel;
      var isNowIndicator = context.options.nowIndicator;
      var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
      return createElement(NowTimer, { unit: isNowIndicator ? "minute" : "day" }, function(nowDate, todayRange) {
        return createElement(TimeCols, __assign({ ref: _this.timeColsRef }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges), todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords }));
      });
    };
    return DayTimeCols2;
  }(DateComponent)
);
function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
  var ranges = [];
  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {
    var date = _a[_i];
    ranges.push({
      start: dateEnv.add(date, dateProfile.slotMinTime),
      end: dateEnv.add(date, dateProfile.slotMaxTime)
    });
  }
  return ranges;
}
var STOCK_SUB_DURATIONS = [
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { seconds: 30 },
  { seconds: 15 }
];
function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
  var dayStart = /* @__PURE__ */ new Date(0);
  var slatTime = slotMinTime;
  var slatIterator = createDuration(0);
  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
  var metas = [];
  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
    var date = dateEnv.add(dayStart, slatTime);
    var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
    metas.push({
      date,
      time: slatTime,
      key: date.toISOString(),
      isoTimeStr: formatIsoTimeString(date),
      isLabeled
    });
    slatTime = addDurations(slatTime, slotDuration);
    slatIterator = addDurations(slatIterator, slotDuration);
  }
  return metas;
}
function computeLabelInterval(slotDuration) {
  var i;
  var labelInterval;
  var slotsPerLabel;
  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {
    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);
    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
    if (slotsPerLabel !== null && slotsPerLabel > 1) {
      return labelInterval;
    }
  }
  return slotDuration;
}
var DayTimeColsView = (
  /** @class */
  function(_super) {
    __extends(DayTimeColsView2, _super);
    function DayTimeColsView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buildTimeColsModel = memoize(buildTimeColsModel);
      _this.buildSlatMetas = memoize(buildSlatMetas);
      return _this;
    }
    DayTimeColsView2.prototype.render = function() {
      var _this = this;
      var _a = this.context, options = _a.options, dateEnv = _a.dateEnv, dateProfileGenerator = _a.dateProfileGenerator;
      var props = this.props;
      var dateProfile = props.dateProfile;
      var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
      var splitProps = this.allDaySplitter.splitProps(props);
      var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
      var dayMinWidth = options.dayMinWidth;
      var hasAttachedAxis = !dayMinWidth;
      var hasDetachedAxis = dayMinWidth;
      var headerContent = options.dayHeaders && createElement(DayHeader, { dates: dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
      var allDayContent = options.allDaySlot !== false && function(contentArg) {
        return createElement(DayTable, __assign({}, splitProps.allDay, { dateProfile, dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: _this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, _this.getAllDayMaxEventProps()));
      };
      var timeGridContent = function(contentArg) {
        return createElement(DayTimeCols, __assign({}, splitProps.timed, { dayTableModel, dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: _this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: _this.handleScrollTopRequest }));
      };
      return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
    };
    return DayTimeColsView2;
  }(TimeColsView)
);
function buildTimeColsModel(dateProfile, dateProfileGenerator) {
  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, false);
}
var OPTION_REFINERS = {
  allDaySlot: Boolean
};
var main = createPlugin({
  initialView: "timeGridWeek",
  optionRefiners: OPTION_REFINERS,
  views: {
    timeGrid: {
      component: DayTimeColsView,
      usesMinMaxTime: true,
      allDaySlot: true,
      slotDuration: "00:30:00",
      slotEventOverlap: true
      // a bad name. confused with overlap/constraint system
    },
    timeGridDay: {
      type: "timeGrid",
      duration: { days: 1 }
    },
    timeGridWeek: {
      type: "timeGrid",
      duration: { weeks: 1 }
    }
  }
});
var main_default = main;
export {
  DayTimeCols,
  DayTimeColsSlicer,
  DayTimeColsView,
  TimeCols,
  TimeColsSlatsCoords,
  TimeColsView,
  buildDayRanges,
  buildSlatMetas,
  buildTimeColsModel,
  main_default as default
};
/*! Bundled license information:

@fullcalendar/timegrid/main.js:
  (*!
  FullCalendar v5.11.5
  Docs & License: https://fullcalendar.io/
  (c) 2022 Adam Shaw
  *)
*/
//# sourceMappingURL=@fullcalendar_timegrid.js.map
