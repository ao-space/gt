import {
  BaseComponent,
  BgEvent,
  DateComponent,
  DateProfileGenerator,
  DayCellContent,
  DayCellRoot,
  DayHeader,
  DaySeriesModel,
  DayTableModel,
  EventRoot,
  Fragment,
  MoreLinkRoot,
  NowTimer,
  PositionCache,
  RefMap,
  SegHierarchy,
  SimpleScrollGrid,
  Slicer,
  StandardEvent,
  ViewRoot,
  WeekNumberRoot,
  addDays,
  addWeeks,
  buildEntryKey,
  buildEventRangeKey,
  buildNavLinkAttrs,
  buildSegTimeText,
  createAriaClickAttrs,
  createElement,
  createFormatter,
  createPlugin,
  createRef,
  diffWeeks,
  getSegAnchorAttrs,
  getSegMeta,
  getStickyFooterScrollbar,
  getStickyHeaderDates,
  getUniqueDomId,
  intersectRanges,
  intersectSpans,
  isPropsEqual,
  memoize,
  renderFill,
  renderScrollShim,
  setRef,
  sortEventSegs
} from "./chunk-SI5S43G7.js";
import {
  __assign,
  __extends,
  __spreadArray
} from "./chunk-EXAMLBMZ.js";

// node_modules/@fullcalendar/daygrid/main.js
import "/home/seb/Desktop/gt/front/node_modules/@fullcalendar/daygrid/main.css";
var TableView = (
  /** @class */
  function(_super) {
    __extends(TableView2, _super);
    function TableView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.headerElRef = createRef();
      return _this;
    }
    TableView2.prototype.renderSimpleLayout = function(headerRowContent, bodyContent) {
      var _a = this, props = _a.props, context = _a.context;
      var sections = [];
      var stickyHeaderDates = getStickyHeaderDates(context.options);
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          chunk: {
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        });
      }
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        chunk: { content: bodyContent }
      });
      return createElement(ViewRoot, { viewSpec: context.viewSpec }, function(rootElRef, classNames) {
        return createElement(
          "div",
          { ref: rootElRef, className: ["fc-daygrid"].concat(classNames).join(" ") },
          createElement(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
        );
      });
    };
    TableView2.prototype.renderHScrollLayout = function(headerRowContent, bodyContent, colCnt, dayMinWidth) {
      var ScrollGrid = this.context.pluginHooks.scrollGridImpl;
      if (!ScrollGrid) {
        throw new Error("No ScrollGrid implementation");
      }
      var _a = this, props = _a.props, context = _a.context;
      var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
      var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
      var sections = [];
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          chunks: [{
            key: "main",
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }]
        });
      }
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        chunks: [{
          key: "main",
          content: bodyContent
        }]
      });
      if (stickyFooterScrollbar) {
        sections.push({
          type: "footer",
          key: "footer",
          isSticky: true,
          chunks: [{
            key: "main",
            content: renderScrollShim
          }]
        });
      }
      return createElement(ViewRoot, { viewSpec: context.viewSpec }, function(rootElRef, classNames) {
        return createElement(
          "div",
          { ref: rootElRef, className: ["fc-daygrid"].concat(classNames).join(" ") },
          createElement(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
        );
      });
    };
    return TableView2;
  }(DateComponent)
);
function splitSegsByRow(segs, rowCnt) {
  var byRow = [];
  for (var i = 0; i < rowCnt; i += 1) {
    byRow[i] = [];
  }
  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
    var seg = segs_1[_i];
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  var byCol = [];
  for (var i = 0; i < colCnt; i += 1) {
    byCol[i] = [];
  }
  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
    var seg = segs_2[_i];
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  var byRow = [];
  if (!ui) {
    for (var i = 0; i < rowCnt; i += 1) {
      byRow[i] = null;
    }
  } else {
    for (var i = 0; i < rowCnt; i += 1) {
      byRow[i] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {
      var seg = _a[_i];
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var TableCellTop = (
  /** @class */
  function(_super) {
    __extends(TableCellTop2, _super);
    function TableCellTop2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TableCellTop2.prototype.render = function() {
      var props = this.props;
      var navLinkAttrs = buildNavLinkAttrs(this.context, props.date);
      return createElement(DayCellContent, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, extraHookProps: props.extraHookProps, defaultContent: renderTopInner }, function(innerElRef, innerContent) {
        return (innerContent || props.forceDayTop) && createElement(
          "div",
          { className: "fc-daygrid-day-top", ref: innerElRef },
          createElement("a", __assign({ id: props.dayNumberId, className: "fc-daygrid-day-number" }, navLinkAttrs), innerContent || createElement(Fragment, null, " "))
        );
      });
    };
    return TableCellTop2;
  }(BaseComponent)
);
function renderTopInner(props) {
  return props.dayNumberText;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  var display = seg.eventRange.ui.display;
  return display === "list-item" || display === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = (
  /** @class */
  function(_super) {
    __extends(TableBlockEvent2, _super);
    function TableBlockEvent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TableBlockEvent2.prototype.render = function() {
      var props = this.props;
      return createElement(StandardEvent, __assign({}, props, { extraClassNames: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
    };
    return TableBlockEvent2;
  }(BaseComponent)
);
var TableListItemEvent = (
  /** @class */
  function(_super) {
    __extends(TableListItemEvent2, _super);
    function TableListItemEvent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TableListItemEvent2.prototype.render = function() {
      var _a = this, props = _a.props, context = _a.context;
      var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
      var timeText = buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);
      return createElement(EventRoot, { seg: props.seg, timeText, defaultContent: renderInnerContent, isDragging: props.isDragging, isResizing: false, isDateSelecting: false, isSelected: props.isSelected, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function(rootElRef, classNames, innerElRef, innerContent) {
        return (
          // we don't use styles!
          createElement("a", __assign({ className: ["fc-daygrid-event", "fc-daygrid-dot-event"].concat(classNames).join(" "), ref: rootElRef }, getSegAnchorAttrs(props.seg, context)), innerContent)
        );
      });
    };
    return TableListItemEvent2;
  }(BaseComponent)
);
function renderInnerContent(innerProps) {
  return createElement(
    Fragment,
    null,
    createElement("div", { className: "fc-daygrid-event-dot", style: { borderColor: innerProps.borderColor || innerProps.backgroundColor } }),
    innerProps.timeText && createElement("div", { className: "fc-event-time" }, innerProps.timeText),
    createElement("div", { className: "fc-event-title" }, innerProps.event.title || createElement(Fragment, null, " "))
  );
}
var TableCellMoreLink = (
  /** @class */
  function(_super) {
    __extends(TableCellMoreLink2, _super);
    function TableCellMoreLink2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.compileSegs = memoize(compileSegs);
      return _this;
    }
    TableCellMoreLink2.prototype.render = function() {
      var props = this.props;
      var _a = this.compileSegs(props.singlePlacements), allSegs = _a.allSegs, invisibleSegs = _a.invisibleSegs;
      return createElement(MoreLinkRoot, { dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: function() {
        var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
        return createElement(Fragment, null, allSegs.map(function(seg) {
          var instanceId = seg.eventRange.instance.instanceId;
          return createElement("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
            visibility: isForcedInvisible[instanceId] ? "hidden" : ""
          } }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, __assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : createElement(TableBlockEvent, __assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
        }));
      } }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
        return createElement("a", __assign({ ref: rootElRef, className: ["fc-daygrid-more-link"].concat(classNames).join(" "), title, "aria-expanded": isExpanded, "aria-controls": popoverId }, createAriaClickAttrs(handleClick)), innerContent);
      });
    };
    return TableCellMoreLink2;
  }(BaseComponent)
);
function compileSegs(singlePlacements) {
  var allSegs = [];
  var invisibleSegs = [];
  for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {
    var placement = singlePlacements_1[_i];
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = (
  /** @class */
  function(_super) {
    __extends(TableCell2, _super);
    function TableCell2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootElRef = createRef();
      _this.state = {
        dayNumberId: getUniqueDomId()
      };
      _this.handleRootEl = function(el) {
        setRef(_this.rootElRef, el);
        setRef(_this.props.elRef, el);
      };
      return _this;
    }
    TableCell2.prototype.render = function() {
      var _a = this, context = _a.context, props = _a.props, state = _a.state, rootElRef = _a.rootElRef;
      var date = props.date, dateProfile = props.dateProfile;
      var navLinkAttrs = buildNavLinkAttrs(context, date, "week");
      return createElement(DayCellRoot, { date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, extraHookProps: props.extraHookProps, elRef: this.handleRootEl }, function(dayElRef, dayClassNames, rootDataAttrs, isDisabled) {
        return createElement(
          "td",
          __assign({ ref: dayElRef, role: "gridcell", className: ["fc-daygrid-day"].concat(dayClassNames, props.extraClassNames || []).join(" ") }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}),
          createElement(
            "div",
            {
              className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner",
              ref: props.innerElRef
              /* different from hook system! RENAME */
            },
            props.showWeekNumber && createElement(WeekNumberRoot, { date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, function(weekElRef, weekClassNames, innerElRef, innerContent) {
              return createElement("a", __assign({ ref: weekElRef, className: ["fc-daygrid-week-number"].concat(weekClassNames).join(" ") }, navLinkAttrs), innerContent);
            }),
            !isDisabled && createElement(TableCellTop, { date, dateProfile, showDayNumber: props.showDayNumber, dayNumberId: state.dayNumberId, forceDayTop: props.forceDayTop, todayRange: props.todayRange, extraHookProps: props.extraHookProps }),
            createElement(
              "div",
              { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
              props.fgContent,
              createElement(
                "div",
                { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
                createElement(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
              )
            ),
            createElement("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
          )
        );
      });
    };
    return TableCell2;
  }(DateComponent)
);
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {
  var hierarchy = new DayGridSegHierarchy();
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  var segInputs = [];
  var unknownHeightSegs = [];
  for (var i = 0; i < segs.length; i += 1) {
    var seg = segs[i];
    var instanceId = seg.eventRange.instance.instanceId;
    var eventHeight = eventInstanceHeights[instanceId];
    if (eventHeight != null) {
      segInputs.push({
        index: i,
        thickness: eventHeight,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  var hiddenEntries = hierarchy.addSegs(segInputs);
  var segRects = hierarchy.toRects();
  var _a = placeRects(segRects, segs, cells), singleColPlacements = _a.singleColPlacements, multiColPlacements = _a.multiColPlacements, leftoverMargins = _a.leftoverMargins;
  var moreCnts = [];
  var moreMarginTops = [];
  for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {
    var seg = unknownHeightSegs_1[_i];
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (var col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {
    var hiddenEntry = hiddenEntries_1[_b];
    var seg = segs[hiddenEntry.index];
    var hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (var col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  var singleColPlacements = [];
  var multiColPlacements = [];
  var leftoverMargins = [];
  for (var col = 0; col < cells.length; col += 1) {
    var rects = rectsByEachCol[col];
    var singlePlacements = [];
    var currentHeight = 0;
    var currentMarginTop = 0;
    for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {
      var rect = rects_1[_i];
      var seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    var multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {
      var rect = rects_2[_a];
      var seg = segs[rect.index];
      var isAbsolute = rect.span.end - rect.span.start > 1;
      var isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  var rectsByEachCol = [];
  for (var col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {
    var rect = rects_3[_i];
    for (var col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  var eventRange = seg.eventRange;
  var origRange = eventRange.range;
  var slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return __assign(__assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: __assign(__assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = (
  /** @class */
  function(_super) {
    __extends(DayGridSegHierarchy2, _super);
    function DayGridSegHierarchy2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.hiddenConsumes = false;
      _this.forceHidden = {};
      return _this;
    }
    DayGridSegHierarchy2.prototype.addSegs = function(segInputs) {
      var _this = this;
      var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);
      var entriesByLevel = this.entriesByLevel;
      var excludeHidden = function(entry) {
        return !_this.forceHidden[buildEntryKey(entry)];
      };
      for (var level = 0; level < entriesByLevel.length; level += 1) {
        entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
      }
      return hiddenSegs;
    };
    DayGridSegHierarchy2.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {
      var _a = this, entriesByLevel = _a.entriesByLevel, forceHidden = _a.forceHidden;
      var touchingEntry = insertion.touchingEntry, touchingLevel = insertion.touchingLevel, touchingLateral = insertion.touchingLateral;
      if (this.hiddenConsumes && touchingEntry) {
        var touchingEntryId = buildEntryKey(touchingEntry);
        if (!forceHidden[touchingEntryId]) {
          if (this.allowReslicing) {
            var placeholderEntry = __assign(__assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
            var placeholderEntryId = buildEntryKey(placeholderEntry);
            forceHidden[placeholderEntryId] = true;
            entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry;
            this.splitEntry(touchingEntry, entry, hiddenEntries);
          } else {
            forceHidden[touchingEntryId] = true;
            hiddenEntries.push(touchingEntry);
          }
        }
      }
      return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);
    };
    return DayGridSegHierarchy2;
  }(SegHierarchy)
);
var TableRow = (
  /** @class */
  function(_super) {
    __extends(TableRow2, _super);
    function TableRow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cellElRefs = new RefMap();
      _this.frameElRefs = new RefMap();
      _this.fgElRefs = new RefMap();
      _this.segHarnessRefs = new RefMap();
      _this.rootElRef = createRef();
      _this.state = {
        framePositions: null,
        maxContentHeight: null,
        eventInstanceHeights: {}
      };
      return _this;
    }
    TableRow2.prototype.render = function() {
      var _this = this;
      var _a = this, props = _a.props, state = _a.state, context = _a.context;
      var options = context.options;
      var colCnt = props.cells.length;
      var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
      var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
      var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
      var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
      var _b = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells), singleColPlacements = _b.singleColPlacements, multiColPlacements = _b.multiColPlacements, moreCnts = _b.moreCnts, moreMarginTops = _b.moreMarginTops;
      var isForcedInvisible = (
        // TODO: messy way to compute this
        props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
      );
      return createElement(
        "tr",
        { ref: this.rootElRef, role: "row" },
        props.renderIntro && props.renderIntro(),
        props.cells.map(function(cell, col) {
          var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
          var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
          return createElement(TableCell, { key: cell.key, elRef: _this.cellElRefs.createRef(cell.key), innerElRef: _this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraHookProps: cell.extraHookProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: _this.fgElRefs.createRef(cell.key), fgContent: (
            // Fragment scopes the keys
            createElement(
              Fragment,
              null,
              createElement(Fragment, null, normalFgNodes),
              createElement(Fragment, null, mirrorFgNodes)
            )
          ), bgContent: (
            // Fragment scopes the keys
            createElement(
              Fragment,
              null,
              _this.renderFillSegs(highlightSegsByCol[col], "highlight"),
              _this.renderFillSegs(businessHoursByCol[col], "non-business"),
              _this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
            )
          ) });
        })
      );
    };
    TableRow2.prototype.componentDidMount = function() {
      this.updateSizing(true);
    };
    TableRow2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var currentProps = this.props;
      this.updateSizing(!isPropsEqual(prevProps, currentProps));
    };
    TableRow2.prototype.getHighlightSegs = function() {
      var props = this.props;
      if (props.eventDrag && props.eventDrag.segs.length) {
        return props.eventDrag.segs;
      }
      if (props.eventResize && props.eventResize.segs.length) {
        return props.eventResize.segs;
      }
      return props.dateSelectionSegs;
    };
    TableRow2.prototype.getMirrorSegs = function() {
      var props = this.props;
      if (props.eventResize && props.eventResize.segs.length) {
        return props.eventResize.segs;
      }
      return [];
    };
    TableRow2.prototype.renderFgSegs = function(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
      var context = this.context;
      var eventSelection = this.props.eventSelection;
      var framePositions = this.state.framePositions;
      var defaultDisplayEventEnd = this.props.cells.length === 1;
      var isMirror = isDragging || isResizing || isDateSelecting;
      var nodes = [];
      if (framePositions) {
        for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {
          var placement = segPlacements_1[_i];
          var seg = placement.seg;
          var instanceId = seg.eventRange.instance.instanceId;
          var key = instanceId + ":" + col;
          var isVisible = placement.isVisible && !isForcedInvisible[instanceId];
          var isAbsolute = placement.isAbsolute;
          var left = "";
          var right = "";
          if (isAbsolute) {
            if (context.isRtl) {
              right = 0;
              left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
            } else {
              left = 0;
              right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
            }
          }
          nodes.push(createElement("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key, ref: isMirror ? null : this.segHarnessRefs.createRef(key), style: {
            visibility: isVisible ? "" : "hidden",
            marginTop: isAbsolute ? "" : placement.marginTop,
            top: isAbsolute ? placement.absoluteTop : "",
            left,
            right
          } }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, __assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : createElement(TableBlockEvent, __assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
        }
      }
      return nodes;
    };
    TableRow2.prototype.renderFillSegs = function(segs, fillType) {
      var isRtl = this.context.isRtl;
      var todayRange = this.props.todayRange;
      var framePositions = this.state.framePositions;
      var nodes = [];
      if (framePositions) {
        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
          var seg = segs_1[_i];
          var leftRightCss = isRtl ? {
            right: 0,
            left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
          } : {
            left: 0,
            right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
          };
          nodes.push(createElement("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? createElement(BgEvent, __assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
        }
      }
      return createElement.apply(void 0, __spreadArray([Fragment, {}], nodes));
    };
    TableRow2.prototype.updateSizing = function(isExternalSizingChange) {
      var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;
      if (!props.forPrint && props.clientWidth !== null) {
        if (isExternalSizingChange) {
          var frameEls = props.cells.map(function(cell) {
            return frameElRefs.currentMap[cell.key];
          });
          if (frameEls.length) {
            var originEl = this.rootElRef.current;
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
        var oldInstanceHeights = this.state.eventInstanceHeights;
        var newInstanceHeights = this.queryEventInstanceHeights();
        var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
        this.safeSetState({
          // HACK to prevent oscillations of events being shown/hidden from max-event-rows
          // Essentially, once you compute an element's height, never null-out.
          // TODO: always display all events, as visibility:hidden?
          eventInstanceHeights: __assign(__assign({}, oldInstanceHeights), newInstanceHeights),
          maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
        });
      }
    };
    TableRow2.prototype.queryEventInstanceHeights = function() {
      var segElMap = this.segHarnessRefs.currentMap;
      var eventInstanceHeights = {};
      for (var key in segElMap) {
        var height = Math.round(segElMap[key].getBoundingClientRect().height);
        var instanceId = key.split(":")[0];
        eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);
      }
      return eventInstanceHeights;
    };
    TableRow2.prototype.computeMaxContentHeight = function() {
      var firstKey = this.props.cells[0].key;
      var cellEl = this.cellElRefs.currentMap[firstKey];
      var fcContainerEl = this.fgElRefs.currentMap[firstKey];
      return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
    };
    TableRow2.prototype.getCellEls = function() {
      var elMap = this.cellElRefs.currentMap;
      return this.props.cells.map(function(cell) {
        return elMap[cell.key];
      });
    };
    return TableRow2;
  }(DateComponent)
);
TableRow.addStateEquality({
  eventInstanceHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  var topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map(function(seg) {
    return {
      seg,
      isVisible: true,
      isAbsolute: true,
      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
      marginTop: 0
    };
  });
}
function buildAbsoluteTopHash(colPlacements) {
  var topsByInstanceId = {};
  for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {
    var placements = colPlacements_1[_i];
    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {
      var placement = placements_1[_a];
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var Table = (
  /** @class */
  function(_super) {
    __extends(Table2, _super);
    function Table2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.splitBusinessHourSegs = memoize(splitSegsByRow);
      _this.splitBgEventSegs = memoize(splitSegsByRow);
      _this.splitFgEventSegs = memoize(splitSegsByRow);
      _this.splitDateSelectionSegs = memoize(splitSegsByRow);
      _this.splitEventDrag = memoize(splitInteractionByRow);
      _this.splitEventResize = memoize(splitInteractionByRow);
      _this.rowRefs = new RefMap();
      _this.handleRootEl = function(rootEl) {
        _this.rootEl = rootEl;
        if (rootEl) {
          _this.context.registerInteractiveComponent(_this, {
            el: rootEl,
            isHitComboAllowed: _this.props.isHitComboAllowed
          });
        } else {
          _this.context.unregisterInteractiveComponent(_this);
        }
      };
      return _this;
    }
    Table2.prototype.render = function() {
      var _this = this;
      var props = this.props;
      var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;
      var rowCnt = props.cells.length;
      var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
      var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
      var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
      var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
      var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
      var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
      var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
      if (limitViaBalanced && !expandRows) {
        limitViaBalanced = false;
        dayMaxEventRows = null;
        dayMaxEvents = null;
      }
      var classNames = [
        "fc-daygrid-body",
        limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
        expandRows ? "" : "fc-daygrid-body-natural"
        // will height of one row depend on the others?
      ];
      return createElement(
        "div",
        { className: classNames.join(" "), ref: this.handleRootEl, style: {
          // these props are important to give this wrapper correct dimensions for interactions
          // TODO: if we set it here, can we avoid giving to inner tables?
          width: props.clientWidth,
          minWidth: props.tableMinWidth
        } },
        createElement(NowTimer, { unit: "day" }, function(nowDate, todayRange) {
          return createElement(
            Fragment,
            null,
            createElement(
              "table",
              { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
                width: props.clientWidth,
                minWidth: props.tableMinWidth,
                height: expandRows ? props.clientHeight : ""
              } },
              props.colGroupNode,
              createElement("tbody", { role: "presentation" }, props.cells.map(function(cells, row) {
                return createElement(TableRow, {
                  ref: _this.rowRefs.createRef(row),
                  key: cells.length ? cells[0].date.toISOString() : row,
                  showDayNumbers: rowCnt > 1,
                  showWeekNumbers: props.showWeekNumbers,
                  todayRange,
                  dateProfile,
                  cells,
                  renderIntro: props.renderRowIntro,
                  businessHourSegs: businessHourSegsByRow[row],
                  eventSelection: props.eventSelection,
                  bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
                  fgEventSegs: fgEventSegsByRow[row],
                  dateSelectionSegs: dateSelectionSegsByRow[row],
                  eventDrag: eventDragByRow[row],
                  eventResize: eventResizeByRow[row],
                  dayMaxEvents,
                  dayMaxEventRows,
                  clientWidth: props.clientWidth,
                  clientHeight: props.clientHeight,
                  forPrint: props.forPrint
                });
              }))
            )
          );
        })
      );
    };
    Table2.prototype.prepareHits = function() {
      this.rowPositions = new PositionCache(
        this.rootEl,
        this.rowRefs.collect().map(function(rowObj) {
          return rowObj.getCellEls()[0];
        }),
        // first cell el in each row. TODO: not optimal
        false,
        true
      );
      this.colPositions = new PositionCache(
        this.rootEl,
        this.rowRefs.currentMap[0].getCellEls(),
        // cell els in first row
        true,
        // horizontal
        false
      );
    };
    Table2.prototype.queryHit = function(positionLeft, positionTop) {
      var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;
      var col = colPositions.leftToIndex(positionLeft);
      var row = rowPositions.topToIndex(positionTop);
      if (row != null && col != null) {
        var cell = this.props.cells[row][col];
        return {
          dateProfile: this.props.dateProfile,
          dateSpan: __assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
          dayEl: this.getCellEl(row, col),
          rect: {
            left: colPositions.lefts[col],
            right: colPositions.rights[col],
            top: rowPositions.tops[row],
            bottom: rowPositions.bottoms[row]
          },
          layer: 0
        };
      }
      return null;
    };
    Table2.prototype.getCellEl = function(row, col) {
      return this.rowRefs.currentMap[row].getCellEls()[col];
    };
    Table2.prototype.getCellRange = function(row, col) {
      var start = this.props.cells[row][col].date;
      var end = addDays(start, 1);
      return { start, end };
    };
    return Table2;
  }(DateComponent)
);
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var DayTableSlicer = (
  /** @class */
  function(_super) {
    __extends(DayTableSlicer2, _super);
    function DayTableSlicer2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.forceDayIfListItem = true;
      return _this;
    }
    DayTableSlicer2.prototype.sliceRange = function(dateRange, dayTableModel) {
      return dayTableModel.sliceRange(dateRange);
    };
    return DayTableSlicer2;
  }(Slicer)
);
var DayTable = (
  /** @class */
  function(_super) {
    __extends(DayTable2, _super);
    function DayTable2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.slicer = new DayTableSlicer();
      _this.tableRef = createRef();
      return _this;
    }
    DayTable2.prototype.render = function() {
      var _a = this, props = _a.props, context = _a.context;
      return createElement(Table, __assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
    };
    return DayTable2;
  }(DateComponent)
);
var DayTableView = (
  /** @class */
  function(_super) {
    __extends(DayTableView2, _super);
    function DayTableView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buildDayTableModel = memoize(buildDayTableModel);
      _this.headerRef = createRef();
      _this.tableRef = createRef();
      return _this;
    }
    DayTableView2.prototype.render = function() {
      var _this = this;
      var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;
      var props = this.props;
      var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
      var headerContent = options.dayHeaders && createElement(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
      var bodyContent = function(contentArg) {
        return createElement(DayTable, { ref: _this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: _this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
      };
      return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
    };
    return DayTableView2;
  }(TableView)
);
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = (
  /** @class */
  function(_super) {
    __extends(TableDateProfileGenerator2, _super);
    function TableDateProfileGenerator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TableDateProfileGenerator2.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {
      var dateEnv = this.props.dateEnv;
      var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);
      var start = renderRange.start;
      var end = renderRange.end;
      var endOfWeek;
      if (/^(year|month)$/.test(currentRangeUnit)) {
        start = dateEnv.startOfWeek(start);
        endOfWeek = dateEnv.startOfWeek(end);
        if (endOfWeek.valueOf() !== end.valueOf()) {
          end = addWeeks(endOfWeek, 1);
        }
      }
      if (this.props.monthMode && this.props.fixedWeekCount) {
        var rowCnt = Math.ceil(
          // could be partial weeks due to hiddenDays
          diffWeeks(start, end)
        );
        end = addWeeks(end, 6 - rowCnt);
      }
      return { start, end };
    };
    return TableDateProfileGenerator2;
  }(DateProfileGenerator)
);
var main = createPlugin({
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      monthMode: true,
      fixedWeekCount: true
    }
  }
});
var main_default = main;

export {
  TableView,
  Table,
  DayTableSlicer,
  DayTable,
  DayTableView,
  buildDayTableModel,
  main_default
};
/*! Bundled license information:

@fullcalendar/daygrid/main.js:
  (*!
  FullCalendar v5.11.5
  Docs & License: https://fullcalendar.io/
  (c) 2022 Adam Shaw
  *)
*/
//# sourceMappingURL=chunk-EOOX4ABT.js.map
